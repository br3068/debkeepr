---
title: "Getting Started with debkeepr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with debkeepr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `debkeepr` package provides an interface for working with non-decimal currencies that use the tripartite system of pounds, shillings, and pence. `debkeepr` provides a means to more easily and accurately perform arithmetic operations on non-decimal monetary values and facilitates the analysis and visualization of larger sets of non-decimal currencies such as those found in historical account books. `debkeepr` accomplishes this through the implementation of the `deb_lsd` and `deb_decimal` classes of vectors, which are based on the infrastructure provided by the [vctrs package](https://vctrs.r-lib.org/). As much as possible, `deb_lsd` and `deb_decimal` vectors behave like numeric vectors. `deb_decimal` vectors conform to the behavior of numeric vectors more closely, and so there are times when transforming a `deb_lsd` vector to `deb_decimal` provides additional capabilities.

This vignette lays out the behavior of the `deb_lsd` and `deb_decimal` classes and shows where they diverge. After a short discussion of the history non-decimal currencies, the basic behavior of the two classes is laid out. The vignette then covers the workings of the two classes as columns in data frames, including an example of visualizing accounts from an account book. For a more in depth discussion of the use cases of `debkeepr` in performing arithmetic calculations on a variety of non-decimal currencies, see the [Transactions in Richard Dafforne's Journal vignette](https://jessesadler.github.io/debkeepr/articles/transactions.html). On the other hand, the [Analysis of Richard Dafforne’s Journal and Ledger vignette](https://jessesadler.github.io/debkeepr/articles/ledger.html) provides an example of an analysis of a historical account book using `debkeepr`.

### Overview

- All of the functions in `debkeepr` begin with the prefix `deb_`, which is short for double-entry bookkeeping.
- The nomenclature used throughout the package follows the [original Latin terms](https://en.wikipedia.org/wiki/%C2%A3sd) in using l, s, and d to represent librae, solidi, and denarii respectively. These terms were translated into the various European languages.
	  - English: pounds, shillings, pence
	  - French: livres, sols or sous, deniers
	  - Italian: lire, soldi, denari
	  - Dutch: ponden, schellingen, groten or penningen
- `debkeepr` contains two data sets from the example journal and ledger in the third edition of Richard Dafforne's *Merchant's Mirrour* from 1660. Dafforne’s text taught the practices of double-entry bookkeeping and provided a full set of account books to be used for educational purposes.
	  - `dafforne_transactions` is a transactions data frame with 177 transactions.
	  - `dafforne_accounts` possesses information about the 46 accounts in the journal and ledger.

## Historical background

The tripartite non-decimal system of pounds, shillings, and pence dates back to the Carolingian Empire. The main coin used in the Late Roman Empire was the golden [solidus](https://en.wikipedia.org/wiki/Solidus_(coin)), introduced by Constantine in 309. However, the shrinking of the economy and political splintering that occurred after the fall of the western Roman Empire diminished the need for gold coins. In the 6th century, the Frankish rulers who took over the Roman mints reacted by creating [triens or tremissis](https://en.wikipedia.org/wiki/Tremissis), smaller gold coins worth one-third of a solidus. From this point, the solidus was no longer produced as a physical coin used for exchange in the western kingdoms. Instead, it continued as a [unit of account](https://en.wikipedia.org/wiki/Unit_of_account) equivalent to three trientes. In the 7th century even devalued golden trientes proved to be too valuable for economic needs. Frankish rulers began to produce silver coins based on the size and weight of the triens. The new silver penny was called a [denarius](https://en.wikipedia.org/wiki/Denarius), linking it to the old silver coin used in the Roman Republic. The silver penny provided the basis for the monetary system of Western Europe until the revival of gold coins in the 14th century.

As the silver denarius overtook the golden triens, the triens became a unit of account equivalent to four denarii. In this way the solidus transformed into a unit of account representing 12 denarii even if 12 silver denarii of the 8th century never would have been equivalent to the pure gold solidus of the Late Roman Empire. The use of the [libra](https://en.wikipedia.org/wiki/Ancient_Roman_units_of_measurement#Weight) as a third unit of account derived from the number of silver denarii struck from a pound, or libra, of silver. Though the actual number of coins struck from a pound of silver differed over time, the rate of 240 coins from a libra lasted long enough to become fossilized in much of Europe.[^1] The custom of counting coins in dozens (solidi) and scores of dozens (librae) spread throughout the Carolingian Empire and became engrained in much of Europe. By the early modern period, a huge variety of monies of accounts had developed across Europe and beyond, and though many used the 1:20:240 ratios, others used a diversity of bases to represent the shillings and pence units.[^2]

## Introducing the `deb_lsd` and `deb_decimal` classes

`debkeepr` introduces two classes to help deal with two interrelated problems associated with historical currencies. Historical currencies consisted of three separate non-decimal units, and the [bases of the shillings and pence units](https://en.wikipedia.org/wiki/Non-decimal_currency) differed by region, coinage, and era. In other words, the actual value represented by say £3 13s. 4d. cannot be determined without knowing the bases of the shillings and pence units. The `deb_lsd` class maintains the tripartite structure of non-decimal currencies and provides a `bases` attribute to record the bases for the shillings and pence units. The `deb_decimal` class represents the values in decimalized form. However, it differs from simply converting the value to a numeric vector by tracking the shillings and pence bases and the unit represented by the decimalized values (libra, solidus, or denarius) through `bases` and `unit` attributes. Thus, though `deb_lsd` and `deb_decimal` vectors of any of the three units will be nominally different, they can represent the same values and currency if the `bases` are equivalent.[^3] The print methods for both classes show the `bases` attribute, and `deb_decimal` vectors include the `unit`.

`deb_lsd` and `deb_decimal` vectors can be created with the `deb_lsd()` and `deb_decimal()` functions respectively. In addition to arguments for the pounds, shillings, and pence values, `deb_lsd()` has an argument for the `bases` of the shillings and pence units, which defaults to the most common bases of 20 shillings to the pound and 12 pence to the shilling: `c(20, 12)`. `deb_decimal()` has the same argument and default for the `bases` and an additional argument to choose the `unit` for the decimalized values that defaults to the pounds unit: `"l"`.

```{r intro-to-classes}
library(debkeepr)

# Create deb_lsd vector of length 3
# with default bases
(lsd <- deb_lsd(l = c(17, 32, 18),
                s = c(13, 11, 10),
                d = c(11, 8, 5)))

# Create deb_decimal vector of length 3
# with default bases and unit
(dec <- deb_decimal(x = c(15.825, 19.25, 9.6125)))

# Express the same values in solidus and denarius units
(dec_s <- deb_decimal(x = c(316.5, 385, 192.25), unit = "s"))
(dec_d <- deb_decimal(x = c(3798, 4620, 2307), unit = "d"))
```

The `bases` argument enables the creation of `deb_lsd` and `deb_decimal` vectors that represent currencies that use non-standard bases for the shillings and pence units such as the Polish florin found in Dafforne's practice journal in which a florin consisted of 30 gros of 18 denars.

````{r polish-florin}
# Create deb_lsd vector of length 3
# with bases of Polish florin
(lsd_polish <- deb_lsd(l = c(32, 12, 26),
                       s = c(15, 1, 20),
                       d = c(5, 13, 8),
                       bases = c(30, 18)))

# Create deb_decimal vector of length 3
# with bases of Polish florin
(dec_polish <- deb_decimal(x = c(15.825, 19.25, 9.6125),
                           bases = c(30, 18)))
```

### Advantages and disadvantages of the `deb_lsd` and `deb_decimal` classes
Why two different classes to represent the same basic information? The goal of `debkeepr` is integrate tripartite non-decimal currencies into the decimalized world of R. The `deb_lsd` class does this while maintaining the tripartite structure of historical non-decimal currencies, but there remain certain limitations to such an approach. The `deb_decimal` class helps to minimize these limitations. The following list provides an overview of the differences of the two classes that are discussed in further detail in the rest of the vignette.

- The `deb_lsd` class has the advantage of maintaining the structure and values used by non-decimal currencies, making it easier to identify and present such values.
- `deb_decimal` implements a wider array of mathematical functions and arithmetic operations than `deb_lsd`.
- Until [dplyr](https://dplyr.tidyverse.org) integrates record-style vectors based on the `vctrs` package more fully — which should happen with version 0.9.0 — `deb_lsd` vectors do not work with the `dplyr` functions `mutate()`, `summarise()`, and `arrange()`. However, the full complement of `dplyr` functions work with `deb_decimal` vectors.
- [ggplot2](https://ggplot2.tidyverse.org) does not know how to pick a scale for `deb_lsd` vectors. However, `deb_decimal` vectors work properly with `ggplot2`, though explicitly identifying the scale as continuous — with `scale_y_continuous()` or `scale_x_continuous()` — is needed to avoid the appearance of a message.
- Casting methods between the two classes with `deb_as_lsd()` and `deb_as_decimal()` make it easy to move between the two classes without losing any data.

## Coercion and casting

It is often necessary to combine vectors of different classes or convert a vector of one class to another. Coercion occurs when vectors are converted implicitly, such as with `c()`. Casting denotes explicit conversion with functions that usually begin with `as`, such as `as.numeric()` or `as.character()`. The `deb_lsd` and `deb_decimal` classes follow a hierarchy in which `numeric()` coerces to `deb_decimal()` coerces to `deb_lsd()`. Coercion with any other type of vector fails.[^4] `debkeepr` also implements casting methods between `deb_lsd` and `deb_decimal` classes, to and from numeric vectors, and to character vectors.

### Coercion
Combining multiple `deb_lsd`, `deb_decimal` and `numeric` vectors follows the hierarchy `numeric()` -> `deb_decimal()` -> `deb_lsd()`.

```{r coercion}
# Combine deb_lsd and deb_lsd
c(lsd, deb_lsd(l = 5, s = 13, d = 4))

# Combine deb_decimal and deb_decimal
c(dec, deb_decimal(x = 17 / 3))
c(dec_s, deb_decimal(x = 17 / 3, unit = "s"))

# Combine deb_lsd, deb_decimal, and numeric
c(lsd, dec, 17 / 3)
```

It is also possible to combine `deb_decimal` vectors that have a different `unit` so long as their `bases` are equivalent.[^5] This follows a set hierarchy that moves towards the higher unit: denarius (`"d"`) -> solidus (`"s"`) -> libra (`"l"`).

```{r unit_coercion}
# denarius -> solidus
c(dec_s, deb_decimal(x = 1360, unit = "d"))
# denarius -> libra
c(dec, deb_decimal(x = 1360, unit = "d"))
# solidus -> libra
c(dec, deb_decimal(x = 340 / 3, unit = "s"))
```

Care needs to be taken when combining `deb_lsd` and/or `deb_decimal` vectors with a base R class using `c()`; `c(deb_lsd(), numeric())` is not equal to `c(numeric(), deb_lsd())`. `c()` does not find the common class for the objects in `c()` if the first element is a base class. Instead, it forces vectors to conform to its internal hierarchy by stripping attributes. Thus, `c(numeric(), deb_lsd())` results in a list with the underlying data of `deb_lsd()`, and `c(numeric(), deb_decimal())`produces a numeric vector. This can be avoided with the use of `vec_c()` from the `vctrs` package, which first finds the common class for all elements.[^6]

```{r c-vs-vec_c}
# Incorrect results with base class as first element
c(17 / 3, lsd)
c(17 / 3, dec)

# Consistent with vec_c()
library(vctrs)

vec_c(17 / 3, lsd)
vec_c(17 / 3, dec)
```

An important aspect of `deb_lsd` and `deb_decimal` vectors is that they cannot be combined in any way if they have different `bases`. Vectors with mismatched bases represent different currencies and so cannot be combined without the user performing an exchange between the two currencies. The only way to combine vectors of different `bases` is explicitly with `deb_convert_bases()`, as shown in greater detail below.

```{r coercion-errors, error = TRUE}
# Cannot combine vectors with different bases
c(lsd, lsd_polish)
c(dec, dec_polish)
```

### Casting
Whereas coercion occurs implicitly, casting is safer because it explicitly changes the class of a vector. `deb_lsd` and `deb_decimal` vectors can be cast to and from each other, to and from `numeric` vectors, and to `character` vectors. Because `deb_lsd` and `deb_decimal` vectors have different capabilities, casting between the classes without any loss of data is important. The ability to cast `deb_lsd` and `deb_decimal` vectors to and from `numeric` vectors provides an outlet for any missing functionality in the two `debkeepr` classes. The drawback to casting between `debkeepr` classes and `numeric` is that the user needs to keep track of the `bases` and `unit` on their own. Finally, casting to a character vector provides a simple outlet to print values, but for presentation of the data, `deb_text()` provides a more flexible manner to nicely format `deb_lsd` and `deb_decimal` vectors.

- `deb_lsd()` to ...
    - `deb_decimal()`: `deb_as_decimal()`
    - `numeric()`: `as.numeric()` and `as.double()`
    - `character()`: `as.character()`

- `deb_decimal()` to ...
    - `deb_lsd()`: `deb_as_lsd()`
    - `numeric()`: `as.numeric()` and `as.double()`
    - `character()`: `as.character()`

- `numeric()` to ...
    - `deb_lsd()`: `deb_as_lsd()`
    - `deb_decimal()`: `deb_as_decimal()`

```{r casting}
# Cast between deb_lsd and deb_decimal
deb_as_lsd(dec)
deb_as_decimal(lsd)

# unit is automatically taken into account
deb_as_lsd(dec_s)

# Can cast to any unit of deb_decimal
deb_as_decimal(lsd, unit = "s")
deb_as_decimal(lsd, unit = "d")

# Cast to and from numeric
deb_as_lsd(c(15.825, 19.25, 9.6125))
deb_as_decimal(c(15.825, 19.25, 9.6125))

as.numeric(lsd)
as.numeric(dec)

# Cast to character
as.character(lsd)
as.character(dec)
```

## Normalization

At the heart of `debkeepr`'s attempt to simplify calculations of non-decimal currencies and integrate them into the structure of R is the concept of normalization. Normalization is the process of converting a set of compound units to a standard form consistent with the bases for each unit in a manner similar to "carrying over" digits in decimal arithmetic. Even the simplest arithmetic operations can be tricky with non-decimal currencies, especially for those schooled in decimal arithmetic. For example, adding together a set of values by hand might result in the non-standard form of £131 83s. 51d. in a currency with the standard bases of 20 shillings per pound and 12 pence per shilling. Normalizing the value by performing integer division on the shillings and pence values by their respective bases, keeping the remainder, and carrying over the quotient to the next unit results in the standardized value of £135 7s. 3d. The process is not difficult, but it is cumbersome and error prone.

`debkeepr` both simplifies the procedure with the `deb_normalize()` function and implements normalization on all mathematical operations with `deb_lsd` vectors, ensuring that normalized values are always returned. For one off calculations, `deb_normalize()` also accepts `numeric` vectors of length three, which is essentially a short cut for `deb_normalize(deb_lsd(l, s, d))`.

```{r addition}
# Normalize £131 83s. 51d.
x <- deb_lsd(131, 83, 51)
deb_normalize(x)

# Normalize numeric vector
deb_normalize(c(131, 83, 51))

# The process is the same for non-standard bases such as Polish florin
# Compare this to deb_normalize(x)
deb_lsd(131, 83, 51, bases = c(30, 18)) %>% 
  deb_normalize()
```

## Arithmetic

`debkeepr` implements a wide array of mathematical functions and arithmetic operations for both the `deb_lsd` and `deb_decimal` classes. The `deb_decimal` class implements methods for the full range of the Summary and Math group generics. The primary functions that are not implemented for either class include `median()`, `quantile()`, and `summary()`. `deb_lsd`, `deb_decimal`, and `numeric` vectors can be combined in mathematical functions and follow the same hierarchy as coercion (`numeric()` -> `deb_decimal()` -> `deb_lsd()`). Most of the mathematical functions act as expected with `deb_lsd` vectors. One exception is the round family of functions, which act on the denarius unit. As always, `deb_lsd` and `deb_decimal` vectors with different `bases` cannot be combined in either mathematical functions or arithmetic operations.

### Implemented mathematical functions for `deb_lsd` vectors
- Summary group: `sum()`, `any()`, and `all()`.
- Math group: `abs()`, `round()`, `signif()`, `ceiling()`, `floor()`, `trunc()`, `cummax()`, `cummin()`, and `cumsum()`.
- Additional generics: `mean()`, `is.nan()`, `is.finite()`, and `is.infinite()`.

```{r mathematics}
# Mathematical functions
sum(lsd)
sum(dec)
sum(lsd, dec)
mean(lsd)
    
# Round works on denarius unit of deb_lsd vector
# and values are normalized
round(deb_lsd(9, 19, 11.825))
```

### Arithmetic operations with `deb_lsd` and `deb_decimal` vectors
`deb_lsd`, `deb_decimal`, and `numeric` vectors can be combined in various ways, producing different results depending on the input types. Note in particular that a wider range of operators can be used with `deb_decimal` and `numeric` vectors than `deb_lsd` and `numeric` vectors.[^7]

- `deb_lsd` and `deb_lsd`: `+`, `-`, and `/`
    - The first two return a `deb_lsd` vector; the last returns a `numeric` vector.
- `deb_lsd` and `numeric`: `*` and `/`
    - Both return a `deb_lsd` vector.
- `numeric` and `deb_lsd`: `*`
    - Returns a `deb_lsd` vector.
- `deb_decimal` and `deb_decimal`: `+`, `-`, and `/`
    - The first two return a `deb_lsd` vector; the last returns a `numeric` vector.
- `deb_decimal` and `numeric`: `+`, `-`, `/`, `*`, `^`, `%%`, and `%/%`
    - All return a `deb_decimal` vector.
- `numeric` and `deb_decimal`: `+`, `-`, and `*`
    - All return a`deb_decimal` vector.
- `deb_lsd` and `deb_decimal`: `+`, `-`, and `/`
    - The first two return a `deb_lsd` vector; the last returns a `numeric` vector.
- `deb_decimal` and `deb_lsd`: `+`, `-`, and `/`
    - The first two return a `deb_lsd` vector; the last returns a `numeric` vector.

```{r arithmetic}
# deb_lsd and deb_decimal vectors
lsd1 <- deb_lsd(15, 15, 9)
lsd2 <- deb_lsd(6, 13, 4)
dec1 <- deb_decimal(15.7875)
dec2 <- deb_decimal(20 / 3)

# deb_lsd and deb_lsd
lsd1 + lsd2
lsd1 / lsd2

# deb_decimal and deb_decimal
dec1 - dec2

# deb_lsd, deb_decimal, and numeric
lsd2 / 2
dec1 + 5.25
18 - dec2
dec1 * 3

# deb_lsd and deb_decimal
lsd1 + dec2
lsd1 / dec1
```

### Equality and comparison
Closely related to mathematical functions and arithmetic operations is the task of testing equality and comparison. `debkeepr` enables testing equality and comparison between `deb_lsd`, `deb_decimal`, and `numeric` vectors. It is possible to compare `deb_decimal` vectors with different `unit`s, but doing so with vectors of different `bases` will throw an error.

```{r comparison, error = TRUE}
# Comparison
lsd1 < lsd2
lsd1 == dec1
lsd2 > 23.5
dec1 < deb_decimal(3390, unit = "d")

# Cannot compare vectors with different bases
lsd1 > lsd_polish

# Maximum and minimum
max(lsd)
min(dec_polish)

# Checking for unique values takes into account units and normalization
unique(lsd1, dec1, deb_lsd(12, 71, 57), deb_decimal(315.75, unit = "s"))
```


## Conversion
All functions that take two `debkeepr` vectors check to ensure that the `bases` of the vectors are equivalent. Any function call that combines vectors with different `bases` throws an error. `debkeepr` is less strict with `deb_decimal` vectors that have a different `unit` since a `unit` is a nominal representation whose relationship to the other units is known through the `bases`. In contrast, `bases` directly affect the underlying value, and the relationship between currencies of different bases cannot be determined through the objects themselves.

With these constraints, `debkeepr` has two ways to explicitly convert the `bases` and `unit` of `deb_lsd` and `deb_decimal` vectors: `deb_convert_bases()` and `deb_convert_unit()`. `deb_convert_bases()` takes a `deb_lsd` or `deb_decimal` vector and converts the value to the `bases` contained in the `to` argument. This will likely be done alongside multiplication of the exchange rate between the two currencies. The [Transactions in Richard Dafforne's Journal vignette](https://jessesadler.github.io/debkeepr/articles/transactions.html) contains a number of examples of this process. `deb_convert_unit()` is simpler in that it uses the `bases` of a `deb_decimal` vector to calculate the conversion to a different `unit`.

A fairly simple example is an exchange between pounds Flemish and guilders from Holland. The two currencies had different bases; guilders possessed the non-standard base of 16 for the denarius unit. However, the currencies were tied together at a rate of six guilders to the £1 Flemish.

```{r conversion, error = TRUE}
# Convert pounds Flemish to guilders
deb_convert_bases(lsd, to = c(20, 16)) * 6
deb_convert_bases(dec, to = c(20, 16)) * 6

# Convert units
deb_convert_unit(dec, to = "d")

# Converting units maintains equality, converting bases does not
dec == deb_convert_unit(dec, to = "d")
lsd == deb_convert_bases(lsd, to = c(20, 16))
```


## Data frames: `deb_lsd` and `deb_decimal` columns

Thus far this vignette has only dealt with `debkeepr` objects as vectors, but, of course, these vectors also work as columns in data frames. `deb_lsd` and `deb_decimal` columns are essential to achieve `debkeepr`'s goal of facilitating reproducible analysis and visualization of larger sets of values found in account books. This section discusses how to create and manipulate data frames with `debkeepr` columns, the current differences between `deb_lsd` and `deb_decimal` columns in `dplyr`, and the process of visualizing the values with `ggplot2`.

```{r packages, message = FALSE}
# load packages
library(tibble)
library(dplyr)
library(ggplot2)
```

The first task is to create a `deb_lsd` or `deb_decimal` column. Such a column can be created with a normal call to `data.frame()` or `tibble()` and a `deb_lsd` or `deb_decimal` vector. However, larger sets of non-decimal values will often be created through the process of transcribing historical data into a spreadsheet of some form. It is recommended to enter the different units into separate columns, which can then be transformed into a `deb_lsd` column with `deb_gather_lsd()`. This is the process used to create the `dafforne_transactions` data that comes with the `debkeepr` package. To restore the data to its original form with three columns for the three units the `deb_spread_lsd()` function can be used.

```{r deb_lsd-df}
# Create data frame with deb_lsd vector
tibble(id = 1:3, lsd = lsd)

# Data frame from separate unit columns with randomly created data
set.seed(240)
raw_data <- tibble(id = 1:10,
                   pounds = sample(20:100, 10, replace = TRUE),
                   shillings = sample(1:19, 10, replace = TRUE),
                   pence = sample(1:11, 10, replace = TRUE))

(lsd_tbl <- deb_gather_lsd(raw_data, l = pounds, s = shillings, d = pence,
                           replace = TRUE))
```

### `deb_lsd` and `deb_decimal` columns with `dplyr`
Currently, `deb_lsd` vectors are not fully integrated into `dplyr`, and so functions such as `summarise()`, `mutate()`, and `arrange()` do not work with `deb_lsd` columns. It is possible to get around these temporary limitation by mutating a `deb_lsd` column to a `deb_decimal` column, which largely behaves as a normal `numeric` variable. An equivalent `deb_lsd` column can be created from a `deb_decimal` column with base R commands.

```{r dplyr, error = TRUE}
# filter() works on a deb_lsd column
lsd_tbl %>% 
  filter(lsd > 75)

# mutate() does not
lsd_tbl %>% 
  mutate(lsd2 = lsd * 2)

# Fix this by creating a deb_decimal column
(lsd2_tbl <- lsd_tbl %>% 
  mutate(dec = deb_as_decimal(lsd),
         dec2 = dec * 2))

# Recreate modified deb_lsd column
lsd2_tbl[["lsd2"]] <- deb_as_lsd(lsd2_tbl[["dec2"]])
lsd2_tbl
```

### Transactions data frames
`debkeepr` has a family of functions designed to work with a specific type of data frame that `debkeepr` refers to as a transactions data frame that has a structure similar to an account book. Transactions data frames possess at minimum "credit" and "debit" variables to record the creditor and debtor accounts of each transaction — the accounts from which a value is taken and to which it is given — and the value of the transactions in a `deb_lsd` or `deb_decimal` column. For a full explanation of how this family of functions works, see `help(deb_account)` and the [Analysis of Richard Dafforne’s Journal and Ledger vignette](https://jessesadler.github.io/debkeepr/articles/ledger.html). It is possible to create a simple transactions data frame from `lsd_tbl` by adding "credit" and "debit" variables. For instance, a merchant might trade in three commodities that each have their own account (let's say wheat, silk, and linen) and a cash account.

```{r transaction-df}
# Create transactions data frame
accounts <- c("wheat", "silk", "linen", "cash")
set.seed(24)
(transactions <- lsd_tbl %>% 
  add_column(credit = sample(accounts, 10, replace = TRUE),
             debit = sample(accounts, 10, replace = TRUE),
             .before = 2))
```

With the properly structured data frame, `debkeepr` makes it easy to find information about the accounts. For example, `deb_account_summary()` finds the total credit, total debit, and current value of each account. Note that the account family of functions can take either a `deb_lsd` or a `deb_decimal` column.

```{r accounts}
(trans_summary <- deb_account_summary(transactions, lsd = lsd,
                                     credit = credit, debit = debit))
```

### Visualizing non-decimal currencies with `ggplot2`

`deb_account_summary()` provides a good basis for a visual overview of the accounts in a transactions data frame. However, alterations to `trans_summary` have to be made to prepare it for plotting with `ggplot2`. `ggplot2` does not know how to pick a scale for `deb_lsd` vectors, but `deb_decimal` vectors work as expected. It is therefore necessary to cast the `deb_lsd` variables to `deb_decimal` either before or within the `ggplot()` call. The only context in which casting to `deb_decimal` results in any loss of information is in labelling the plotted values. However, this can be rectified through the `deb_text()` function, which provides a flexible way to format `deb_lsd` and `deb_decimal` vectors as text. The following command makes these changes while also converting the "debit" column to negative values for the purpose of distinguishing them from the credit values.

```{r prep-ggplot}
dec_summary <- trans_summary %>% 
  mutate_if(deb_is_lsd, deb_as_decimal) %>% 
  mutate(debit = -debit,
         current_text = deb_text(deb_as_lsd(current)))
```

At this point, the data can be plotted as if the values were `deb_decimal` values were `numeric`. The only notable difference is the need to explicitly call `scale_y_continuous()` to avoid a message, but in this case, `scale_y_continuous()` is also used to label the axis with the pound sign.

```{r ex-plot, fig.height = 4, fig.width = 8}
ggplot(data = dec_summary) + 
	geom_linerange(aes(x = account_id, ymin = debit, ymax = credit)) + 
	geom_point(aes(x = account_id, y = current)) +
  geom_text(aes(x = account_id, y = current, label = current_text), nudge_x = 0.32) + 
  scale_y_continuous(labels = scales::dollar_format(prefix = "£")) + 
	labs(x = "Accounts",
		   y = "Value in pounds",
	     title = "Summary of the accounts") + 
  theme_light()
```


## Useful works on monetary systems and the history of accounting
- Peter Spufford, *Money and its Use in Medieval Europe* (Cambridge: Cambridge University Press, 1988), especially pages 411–414, for a discussion of money of account in medieval Europe.
- John Richard Edwards and Stephen P. Walker, eds. *The Routledge Companion to Accounting History* (New York: Routledge Taylor & Francis Group, 2009).
- Jacob Soll, *The Reckoning: Financial Accountability and the Rise and Fall of Nations* (New York: Basic Books, 2014).
- John Geijsbeek, *Ancient Double-Entry Bookkeeping: Lucas Pacioli’s Treatise (A.D. 1494, the Earliest Known Writer on Bookkeeping) Reproduced and Translated with Reproductions, Notes, and Abstracts from Manzoni, Pietra, Mainardi, Ympyn, Stevin, and Dafforne* (Denver: John Geijsbeek, 1914).

[^1]:	Using the bases of 20 and 12 also had certain [arithmetic advantages](https://en.wikipedia.org/wiki/Duodecimal).

[^2]:	For more information about the development of the system of pounds, shillings, and pence and medieval monetary systems more generally see Peter Spufford, *Money and its Use in Medieval Europe* (Cambridge: Cambridge University Press, 1988).

[^3]: It is for this reason that any function call that combines `debkeepr` vectors with different `bases` throws an error, while `deb_decimal` vectors with a different `unit` can be safely combined. The nominal difference between the three units is contained in the bases of the shillings and pence units.

[^4]: See the [S3 vectors vignette](https://vctrs.r-lib.org/articles/s3-vector.html#casting-and-coercion) in the `vctrs` package for a fuller explanation of these terms. For a discussion of the goals of type stability for coercion, see the [Type and size stability vignette](https://vctrs.r-lib.org/articles/stability.html) in the same package.

[^5]: Coercion of `deb_decimal` vectors with different `unit`s is implemented because, like `deb_lsd` and `deb_decimal` vectors, `deb_decimal` vectors with different `unit`s differ nominally, but, so long as they have equivalent `bases`, they represent values within the same currency.

[^6]: For further details on the issues with and inconsistencies of `c()`, as well as the reasoning behind the the implementation of `vctrs::vec_c()`, see the [Type and size stability vignette](https://vctrs.r-lib.org/articles/stability.html#c-and-vctrsvec_c) in the `vctrs` package.

[^7]: The difference between the behavior of `deb_lsd` and `deb_decimal` vectors with `numeric` vectors is primarily an implementation detail. It is a recognition of the closer relationship of `deb_decimal` to numeric vectors than `deb_lsd` to `numeric` vectors and of the relative ease of casting back and forth between `deb_lsd` to `deb_decimal` vectors.
